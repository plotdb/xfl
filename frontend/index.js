// Generated by LiveScript 1.3.1
var xfl;
xfl = {
  fonts: {},
  isCJK: function(){
    return (code >= 0xff00 && code <= 0xffef) || (code >= 0x4e00 && code <= 0x9fff);
  },
  load: function(path, options, callback){
    var ref$, cb, ext, name, slug, font, format, xhr, this$ = this;
    options == null && (options = {});
    if (!path) {
      return;
    }
    ref$ = [path.replace(/\/$/, ''), typeof options === 'function' ? options : callback], path = ref$[0], cb = ref$[1];
    if (this.fonts[path]) {
      return cb ? cb(this.fonts[path]) : null;
    }
    ref$ = [
      ((/\.([a-zA-Z0-9]+)$/.exec(path) || [])[1] || '').toLowerCase(), options.fontName || (ref$ = path.replace(/\.[a-zA-Z0-9]+$/, '').split("/").filter(function(it){
        return it;
      }))[ref$.length - 1], options.fontName || Math.random().toString(16).substring(2)
    ], ext = ref$[0], name = ref$[1], slug = ref$[2];
    this.fonts[path] = font = {
      name: name,
      path: path,
      options: options,
      className: "xfl-" + slug,
      codeToSet: {},
      hit: {},
      url: {},
      ext: ext && ~['woff2', 'woff', 'eot', 'ttf', 'otf'].indexOf(ext) ? ext : null
    };
    font.ajax = function(idxlist, cb){
      var check, this$ = this;
      check = function(){
        if (idxlist.map(function(it){
          return this$.url[it];
        }).filter(function(it){
          return it;
        }).length === idxlist.length) {
          return cb();
        }
      };
      return idxlist.map(function(d, i){
        var xhr;
        if (this$.url[d]) {
          return check();
        }
        xhr = new XMLHttpRequest();
        xhr.addEventListener('readystatechange', function(){
          if (xhr.readyState !== 4) {
            return;
          }
          this$.url[d] = URL.createObjectURL(xhr.response);
          return check();
        });
        xhr.open('GET', path + "/" + d + ".ttf");
        xhr.responseType = 'blob';
        return xhr.send();
      });
    };
    font.sync = function(txt, cb){
      var ref$, misschar, missset, i$, to$, i, code, setIdx, k, this$ = this;
      txt == null && (txt = "");
      if (this.nosync) {
        return cb ? cb() : '';
      }
      ref$ = [{}, {}], misschar = ref$[0], missset = ref$[1];
      for (i$ = 0, to$ = txt.length; i$ < to$; ++i$) {
        i = i$;
        code = txt.charCodeAt(i);
        if (options.cjkOnly && !xfl.isCJK(code)) {
          continue;
        }
        setIdx = this.codeToSet[code.toString(16)];
        if (!setIdx) {
          misschar[txt[i]] = true;
        } else if (!this.hit[setIdx]) {
          this.hit[setIdx] = missset[setIdx] = true;
        }
      }
      misschar = (function(){
        var results$ = [];
        for (k in misschar) {
          results$.push(k);
        }
        return results$;
      }()).filter(function(it){
        return it.trim();
      });
      if (misschar.length) {
        console.log("not supported chars: " + misschar.join(''));
      }
      return this.ajax((function(){
        var results$ = [];
        for (k in missset) {
          results$.push(k);
        }
        return results$;
      }()), function(){
        var k, ref$, css, idxlist, i$, len$, idx, url, names;
        ref$ = [
          "", (function(){
            var results$ = [];
            for (k in this.hit) {
              results$.push(k);
            }
            return results$;
          }.call(this$))
        ], css = ref$[0], idxlist = ref$[1];
        for (i$ = 0, len$ = idxlist.length; i$ < len$; ++i$) {
          idx = idxlist[i$];
          url = this$.url[idx] || path + "/" + idx + ".woff2";
          css += "@font-face {\n  font-family: " + name + ";\n  src: url(" + url + ") format('woff2');\n}";
        }
        names = idxlist.map(function(it){
          return name + "-" + it;
        }).join(',');
        css += "." + this$.className + " { font-family: " + name + "; }";
        this$.css = css;
        xfl.update();
        if (cb) {
          return cb();
        }
      });
    };
    if (font.ext) {
      font.nosync = true;
      format = font.ext && font.ext !== 'ttf' ? "format('" + font.ext + "')" : '';
      font.css = "@font-face {\n  font-family: " + name + ";\n  src: url(" + path + ") " + format + ";\n}\n." + font.className + " { font-family: \"" + name + "\"; }";
      xfl.update();
      if (cb) {
        return cb(font);
      }
    } else {
      xhr = new XMLHttpRequest();
      xhr.addEventListener('readystatechange', function(){
        var hash;
        if (xhr.readyState !== 4) {
          return;
        }
        hash = {};
        xhr.responseText.split('\n').map(function(d, i){
          return d.split(' ').map(function(e, j){
            return hash[e] = i + 1;
          });
        });
        font.codeToSet = hash;
        if (cb) {
          return cb(font);
        }
      });
      xhr.open('GET', path + "/charmap.txt");
      return xhr.send();
    }
  },
  update: function(){
    var css, k, v, node;
    css = (function(){
      var ref$, results$ = [];
      for (k in ref$ = xfl.fonts) {
        v = ref$[k];
        results$.push(v.css || '');
      }
      return results$;
    }()).join('\n');
    node = xfl.node || document.createElement("style");
    node.textContent = css;
    if (xfl.node) {
      return;
    }
    node.setAttribute('type', 'text/css');
    document.body.appendChild(node);
    return xfl.node = node;
  }
};